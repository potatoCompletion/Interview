# - 기술면접 대비 (자료구조)-

<br>
<br>
<br>

# 1. Array는 어떤 자료구조 인가요?
- Array는 메모리상에 순차적으로 미리 할당된 크기만큼 저장하는 자료구조입니다.
- 순차적으로 저장이 되어 있기 때문에 중간에 있는 데이터에도 인덱싱을 통해 한번에 접근을 할 수 있다는 장점이 있습니다.
- 하지만 미리 크기를 할당해줘야 해서 불필요한 메모리 낭비가 발생할 수 있고, 마지막 데이터를 제외하고 삽입과 삭제를 할 경우 해당 데이터의 뒤에 있는 모든 데이터들을 한 칸씩 옮겨줘야 한다는 단점이 있습니다.
- 시간복잡도는 조회 시 O(1), 마지막 인덱스를 제외한 삽입/삭제 및 탐색은 O(n)입니다.

<br>
<br>
<br>

# 2. Dynamic Array는 어떤 자료구조 인가요?
- Dynamic Array는 기존 Array의 단점인 미리 크기를 지정해 줘야 한다는 단점을 보안하기 위해 나온 자료구조입니다. 그 방식으로 resize를 사용합니다.
- resize란 할당된 크기가 다 채워지고 새로운 데이터를 추가하려고 할 때 기존 Dynamic Array의 크기보다 더 큰 사이즈의 Array를 새로 할당해서 데이터를 추가하는 방식입니다.
- 단점으로는 resize 시 기존의 데이터를 모두 새로운 Array에 옮겨줘야 하기 때문에 퍼포먼스가 굉장히 느려진다는 단점이 있습니다.
- 시간복잡도는 Array와 동일하지만 resize가 일어나는 삽입의 경우 O(n)입니다.

<br>
<br>
<br>

# 3. Linked List는 어떤 자료구조 인가요?
- Linked List는 메모리상에는 불연속적으로 데이터가 저장되지만, 다음 데이터의 주소값을 가짐으로써 논리적 연속성을 가지는 자료구조 입니다.
- 메모리상에 순차적으로 데이터가 저장되어 있지 않기 때문에 중간 값에 바로 접근을 할 수 없다는 단점을 가지고 있습니다. 하지만 반대로 순차적으로 데이터가 저장되어 있지 않기 때문에 데이터의 삽입/삭제가 용이하다는 장점이 있습니다.
- 또한 데이터를 추가 할 때마다 메모리 공간을 할당받기 때문에 불필요한 메모리 할당을 방지할 수 있습니다.
- 하지만 데이터 말고도 주소값을 저장하기 위한 메모리를 추가적으로 사용하기 때문에 저장할 데이터의 개수를 미리 알고 있다면 Array가 더 효율적으로 메모리를 사용합니다.
- 시간복잡도는 삽입/삭제 시 O(1), 조회 시 O(n)

<br>
<br>
<br>

# 4. Array와 Linked List의 memory allocation은 언제 어떻게 일어나나요?
- Array는 미리 크기가 할당되어 있기 때문에 compile 단계에서 stack 영역에 메모리를 할당 받습니다.
- Linked List는 프로그램이 실행되고 있는 와중에 데이터가 들어오고 들어올 때마다 메모리 할당이 일어나기 때문에 runtime 단계에서 heap 영역에 메모리를 할당 받습니다.

<br>
<br>
<br>

# 5. Queue는 어떤 자료구조 인가요?
- Queue는 선입선출(FIFO)의 특성을 가지는 자료구조 입니다. 활용 예시로는 하나의 자원을 공유하는 프린터, 캐시 구현, 프로세스 관리, 너비우선탐색(BFS) 등이 있습니다.
- enqueue와 dequeue 모두 O(1)의 시간복잡도를 갖습니다.
- Array-based 형식과 List-based 형식 두 가지로 구현할 수 있습니다.
- Array-based는 enqueue와 dequeue 과정에서 남는 메모리가 생깁니다. 따라서 메모리의 낭비를 줄이기 위해 주로 Circular queue 형식으로 구현합니다.
- Circular queue는 array의 마지막 공간까지 데이터가 모두 인큐 됐을 경우, 디큐로 인해 비어있는 앞 공간에 데이터를 인큐하는 방식입니다. 또한, enqueue가 계속 발생해서 fixed size를 넘어서게 되기 때문에 dynamic array와 같은 방식으로 resize를 해주어야 합니다.
- List-based는 보통 singly-linked list로 구현을 합니다. 인큐의 경우, 단순히 append를 하는 것으로 구현되고, 디큐의 경우 맨 앞의 요소를 삭제하는 것으로 구현을 합니다.
- 두 종류 모두 인큐와 디큐의 시간복잡도는 O(1)의 시간복잡도를 갖습니다.
- array-based의 경우 전반적으로 퍼포먼스가 좋지만 worst case(resize를 수행하는 경우) 훨씬 느릴 수 있습니다.
- list-based의 경우 인큐를 할 떄마다 메모리 할당을 해줘야 하기 때문에 전반적으로 느리다고 할 수 있습니다.

<br>
<br>
<br>

# 6. Stack은 어떤 자료구조 인가요?
- Stack은 후입선출(LIFO)의 특성을 가지는 자료구조 입니다. 활용 예시로는 함수의 콜스택, 인터넷 브라우저의 뒤로가기, 깊이우선탐색(DFS) 등이 있습니다.
- Push와 Pop 모두 O(1)의 시간복잡도를 가집니다.

<br>
<br>
<br>

# (!)7. Queue와 Priority Queue를 비교해보세요. (!)
- 먼저 들어온 순서대로 dequeue가 일어나는 queue와 달리, priority queue는 우선 순위가 가장 높은 데이터부터 dequeue를 합니다.
- queue의 enqueue와 dequeue 시간복잡도는 O(1) 이지만, priority queue의 enqueue와 dequeue 시간복잡도는 O(logN) 입니다.
- priority queue는 Heap의 구현과 일치합니다. Heap은 이진완전트리 구조이고 각 노드에 저장된 값이 child node에 저장된 값보다 크거나 같으면 max heap, 작거나 같으면 min heap이라고 부릅니다.
- 트리는 보통 Linked list로 구현합니다. 하지만 Heap은 트리임에도 불구하고 Array로 구현해야 합니다. 그 이유는 새로운 노드를 Heap의 마지막 위치에 저장해야 하는데, 이 때 Array 기반으로 구현해야 이 과정이 수월하기 때문입니다.
- 노드의 left child node는 2n(부모노드의 인덱스) 인덱스 이고, right child node는 2n+1 인덱스입니다. 어떠한 노드의 부모 노드는 n/2 인덱스 입니다. (7의 부모 노드는 3)
- Heap의 push는 우선 가장 마지막 위치에 저장합니다. 그리고 해당 인덱스를 2로 나눠서 부모 노드의 값과 비교합니다. 이러한 연산을 부모 노드와 값이 같거나 작을 때까지 반복합니다.
- Heap의 pop은 root node를 반환합니다. 그 후 마지막 위치에 있는 노드를 우선 루트 노드로 지정합니다. 그 후 두 개의 자식 노드 중 더 큰 값을 찾고 그 값과 비교하여 루트 노드가 더 작을 경우 스왑합니다. 이 연산을 루트 노드가 더 클 때까지 반복합니다.

<br>
<br>
<br>

# (!)(!)8. BST는 어떤 자료구조 인가요? (!)(!)
- BST는 이진탐색트리(Binary Search Tree) 입니다. 특징으로는 노드 기준 왼쪽 서브트리에는 노드보다 작은 값들만 저장이되고, 오른쪽으로는 노드보다 큰 값들만 저장이 됩니다. 이로 인해 항상 정렬이 된 상태를 유지하고 있고, 이는 곧 탐색에 있어 기존 이진완전트리보다 우월함을 가집니다.
- 이진트리란 항상 자식 노드의 개수가 2개 이하로 유지되는 트리를 의미합니다.
- BST에서 특정 값을 찾을 때에는 루트 노드부터 시작해서 해당 값보다 큰지 작은지를 비교하며 왼쪽 혹은 오른쪽으로 탐색을 시작합니다. 이러한 특성 때문에 시간복잡도는 O(logN)을 갖습니다.
- BST의 삽입/삭제는 탐색과 마찬가지로 루트 노드부터 시작해서 해당 값보다 큰지 작은지를 비교하며 왼쪽 혹은 오른쪽으로 재귀합니다. 마찬가지로 시간복잡도 역시 O(logN)을 갖습니다.
- 하지만 worst case의 경우가 있는데, 이는 노드가 한쪽으로 쏠리는 때입니다. 이 때는 시간복잡도가 O(n)으로 증가해서 실질적으로 링크드리스트에 데이터를 저장한 것과 크게 다르지 않게되는 단점이 있습니다.
- 이러한 해결하기 위해서 Balance tree 입니다. 밸런스 트리는 노드의 삽입/삭제 시에 자체적으로 구조를 조정해서 트리의 높이를 최대한 낮게 설정합니다. 이러한 특징 때문에 항상 시간복잡도를 O(logN)으로 유지한다는 특징이 있습니다. 단점으로는 삽입/삭제 시에 항상 구조를 조정하기 때문에 성능 상 일반 트리보다 연산이 많다는 단점이 있습니다.
- 밸런스 트리의 예시로는 btree와 red-black tree 등이 있습니다. 이 중 btree의 경우 데이터베이스의 인덱스를 설정할 때의 자료구조로 이용됩니다.
- java에서는 hashmap의 separate chaning으로써 linked list와 red-black 트리를 병행하여 저장합니다.

<br>
<br>
<br>

# (!)(!)9. Hash Table은 어떤 자료구조 인가요? (!)(!)
- 해시테이블은 키, 밸류 쌍의 데이터를 받아 키 값을 hash function을 이용해 해싱하고 그 결과로 나온 해시 값의 인덱스에 자료를 저장합니다. 그렇기 때문에 기본적으로 Array를 기반으로 만들어진 자료구조 입니다.
- 단순히 키 값을 인덱스로 저장하는 Direct-address table과 비교했을 때 해시 펑션을 이용하기 때문에 숫자 뿐만 아니라 스트링 형태의 자료 또한 키 값으로 받을 수 있다는 장점이 있고, 키 값으로 매우 큰 값이 들어왔을 때 앞에 무수히 많은 불필요한 공간 낭비가 일어나는 문제를 방지합니다.
  = 좋은 해시 함수란 상황마다 다르지만, 일반적으로 연산속도가 빨라야 하고 해시 충돌을 최대한 피할 수 있는 함수가 일반적으로 좋은 해시 함수라고 말할 수 있습니다.
- 시간복잡도는 삽입/삭제/검색 모두 기본적으로 O(1)이지만, 해시 충돌이 발생할 경우 최악의 경우 O(n)이 될 수 있습니다.
  = 이 때문에 해시 충돌을 최대한 피해야 합니다.

# (!)(!)(!)(!)10. Hash table에서 collision 발생 시 어떻게 되나요? 해결방법엔 어떤게 있나요? (!)(!)(!)(!)
- 해시 충돌이 발생할 경우 이를 해결 하기 위해서 대표적으로 2가지 방법이 있습니다.
- 첫번째는 Open Addressing 방법으로 해시 충돌이 발생하면 충돌이 발생한 인덱스에 특정 값을 더한 위치에 데이터를 저장하는 방법입니다. 이 때 특정 값을 얻기 위한 방법으로 Linear probing, Quadratic probing, double hashing이 있습니다.
- Linear probing이란 인덱스 값에 1씩 더해줘서 빈 공간을 찾아내는 방법이고, quadratic probing은 해당 인덱스 값에 제곱을 해서 빈 공간을 찾아내는 방법입니다. 이 두가지 방법을 사용하게 되면 특정 영역에 데이터가 집중적으로 몰리는 클러스터링 현상이 발생할 수 있고 이로 인해 탐색시간이 증가하게 된다는 단점이 있습니다.
- Double Hasing이란 앞서 말한 두가지 방식처럼 일정한 간격을 더해서 빈 공간을 찾아내는 것이 아닌, 해시 함수를 하나 더 만들어서 인덱스에 더할 탐사 이동폭 또한 해시 값으로 정하는 방식입니다. 이 방식을 사용하면 클러스터링 현상을 최소화 할 수 있습니다.

- 두번째는 separate chaning 방법입니다. 이 방법은 array 하나를 사용하는 것이 아닌 링크드리스트를 추가적으로 이용해서 키, 밸류 값을 연결된 노드에 저장하는 방식입니다. 충돌이 일어날 경우 하나의 노드를 더 삽입해서 저장합니다.
- n개의 키가 모두 동일한 해시 값을 갖게 되면 길이가 n개인 링크드리스트가 생성됩니다. 이 때 특정 key를 찾기 위해서 길이 n의 linked list를 탐색하는 O(n)의 시간복잡도를 갖게 됩니다.
- 삽입의 시간복잡도는 O(1)을 갖습니다. 하지만 탐색/삭제의 시간복잡도는 worst case일 때 O(n)까지 늘어날 수 있습니다. 이러한 worst case를 방지하기 위해 java에서는 단순 링크드리스트가 아닌 red-black 트리를 이용해 탐색 시간 복잡도를 하상 O(logN)으로 유지합니다.

